<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>基础知识 | Bowen&#39;s Academic Home</title>
    <link>https://bowenei.gitee.io/learn/algorithm/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
      <atom:link href="https://bowenei.gitee.io/learn/algorithm/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.xml" rel="self" type="application/rss+xml" />
    <description>基础知识</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sat, 16 Oct 2021 20:53:08 +0800</lastBuildDate>
    <image>
      <url>https://bowenei.gitee.io/media/icon_huc813daf5dbf7d2b27f0daba22fe1e0fb_68056_512x512_fill_lanczos_center_3.png</url>
      <title>基础知识</title>
      <link>https://bowenei.gitee.io/learn/algorithm/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
    </image>
    
    <item>
      <title>算法分析</title>
      <link>https://bowenei.gitee.io/learn/algorithm/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 16 Oct 2021 20:49:20 +0800</pubDate>
      <guid>https://bowenei.gitee.io/learn/algorithm/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;算法执行效率的评估&#34;&gt;算法执行效率的评估&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;经验法&lt;/strong&gt;：对各种算法编程，用不同实例进行实验；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;理论法&lt;/strong&gt;：以数学化的方式确定算法所需要资源数与实例大小之间函数关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;经验法的问题&#34;&gt;经验法的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;依赖于计算机&lt;/li&gt;
&lt;li&gt;依赖于语言/编程技能&lt;/li&gt;
&lt;li&gt;需要一定的编程/调试时间&lt;/li&gt;
&lt;li&gt;只能评估部分实例的效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;理论法的优点&#34;&gt;理论法的优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不依赖于计算机&lt;/li&gt;
&lt;li&gt;不依赖于语言/编程技能&lt;/li&gt;
&lt;li&gt;节省了无谓编程时间&lt;/li&gt;
&lt;li&gt;可研究任何在实例上算法效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;算法好坏的衡量&#34;&gt;算法好坏的衡量&lt;/h2&gt;
&lt;p&gt;最初，用所需计算时间来衡量算法的好坏。但不同的机器相互之间无法比较，故需要用独立于具体计算机的客观衡量标准：&lt;/p&gt;
&lt;h3 id=&#34;问题的规模&#34;&gt;问题的规模&lt;/h3&gt;
&lt;p&gt;输入规模通常用 $n$ 来表示，也可有两个以上的参数，如图中的顶点数和边数。&lt;/p&gt;
&lt;h3 id=&#34;基本运算&#34;&gt;基本运算&lt;/h3&gt;
&lt;p&gt;基本运算是解决给定问题时占支配地位的运算。通常情况下，讨论一个算法优劣时，我们只讨论基本运算的执行次数。因为它是占支配地位的，而其它的运算可以忽略不计。&lt;/p&gt;
&lt;p&gt;基本运算是算法中最为基本的运算，在伪代码中很容易识别，而且与编程语言无关。假设在每个基本运算都在RAM模型中花费一定的时间，无需精确衡量执行多少时间。&lt;/p&gt;
&lt;h3 id=&#34;算法的计算量函数&#34;&gt;算法的计算量函数&lt;/h3&gt;

$$
C = T(N, I, A)
$$

&lt;p&gt;式中，$N$ 表示问题的规模，$I$ 表示输入，$A$ 表示算法本身。&lt;/p&gt;
&lt;p&gt;变量 $A$ 可以隐去，通常研究算法在一台抽象计算机上运行所需时间。&lt;/p&gt;
&lt;p&gt;其实变量 $I$ 也可以隐去，因为不必研究每种合法输入的计算量，只需要考虑算法的最好情况、最坏情况和平均情况。&lt;/p&gt;
&lt;p&gt;那么最终算法的计算量函数就可以简化为：&lt;/p&gt;

$$
C = T(N)
$$

&lt;h2 id=&#34;算法的时间复杂度&#34;&gt;算法的时间复杂度&lt;/h2&gt;
&lt;p&gt;用输入规模的某个函数来表示算法的基本运算量，称为算法的时间复杂度，即：&lt;/p&gt;

$$
C = T(N)
$$

&lt;h3 id=&#34;复杂性渐进形态&#34;&gt;复杂性渐进形态&lt;/h3&gt;
&lt;p&gt;当比较两个算法的渐近复杂性的阶不同时，只要确定各自的阶，即可判定哪个算法效率高。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;渐近上界记号 $O$&lt;/li&gt;
&lt;li&gt;渐进下界记号 $\Omega$&lt;/li&gt;
&lt;li&gt;紧渐近界记号 $\Theta$&lt;/li&gt;
&lt;li&gt;非紧上界记号 $o$&lt;/li&gt;
&lt;li&gt;非紧下界记号 $\omega$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;和的估计与界限&#34;&gt;和的估计与界限&lt;/h3&gt;
&lt;p&gt;结合数学上的数列求和方法以及求积分的方法求解。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>递归方程</title>
      <link>https://bowenei.gitee.io/learn/algorithm/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%80%92%E5%BD%92%E6%96%B9%E7%A8%8B/</link>
      <pubDate>Sat, 16 Oct 2021 20:49:47 +0800</pubDate>
      <guid>https://bowenei.gitee.io/learn/algorithm/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%80%92%E5%BD%92%E6%96%B9%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;归并排序算法的递归方程&#34;&gt;归并排序算法的递归方程&lt;/h2&gt;

$$
\begin{align}
T(n) = \begin{cases}
\Theta(1) &amp; n=1 \\\\
2T(\frac{n}{2})+\Theta(n) &amp; n&gt;1
\end{cases}
\end{align}
$$

&lt;p&gt;这个方程的含义是如果只有 $1$ 个元素的数组需要做归并排序，那么在常数时间内就能得到有序数组。&lt;/p&gt;
&lt;p&gt;如果是 $n$ 个元素的数组需要做归并排序，那么需要将问题一分为二，每个子问题各需要 $T(\frac{n}{2})$ 的时间。解决子问题以后，当前问题转化为合并有序数组问题，两个指针会不重复扫描每个元素一遍，复杂度为 $\Theta(n)$。&lt;/p&gt;
&lt;p&gt;可以使用逐层展开法和变量替换法求解 $T(n)$，但是比较麻烦，仅作了解即可。&lt;/p&gt;
&lt;h2 id=&#34;master-定理&#34;&gt;Master 定理&lt;/h2&gt;

$$
T(n) = aT(\frac{n}{b})+f(n), a \ge 1, b &gt; 1, f(n) &gt; 0
$$

&lt;p&gt;比较 $n ^ {\log_{b}{a}}$ 的阶和 $f(n)$ 的大小：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 $n ^ {\log_{b}{a}}$ 大，则 $T(n) = \Theta(n ^ {\log_{b}{a}})$&lt;/li&gt;
&lt;li&gt;若 $f(n)$ 大，则 $T(n) = \Theta(f(n))$&lt;/li&gt;
&lt;li&gt;若 $n ^ {\log_{b}{a}} = f(n)$，则 $T(n) = \Theta(n ^ {\log_{b}{a}} \log_{}{n}) = \Theta(f(n) \log_{}{n})$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于归并排序，$a=2$，$b=2$，则 $n ^ {\log_{b}{a}} = n$。而 $f(n) = \Theta(n)$，它们的阶数相当。因此归并排序的时间复杂度 $T(n) = \Theta(n\log_{}{n})$。&lt;/p&gt;
&lt;h2 id=&#34;master-定理的证明&#34;&gt;Master 定理的证明&lt;/h2&gt;</description>
    </item>
    
  </channel>
</rss>
