<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>图论算法 | Bowen&#39;s Academic Home</title>
    <link>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/</link>
      <atom:link href="https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <description>图论算法</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sun, 07 Nov 2021 15:30:20 +0800</lastBuildDate>
    <image>
      <url>https://bowenei.gitee.io/media/icon_huc813daf5dbf7d2b27f0daba22fe1e0fb_68056_512x512_fill_lanczos_center_3.png</url>
      <title>图论算法</title>
      <link>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/</link>
    </image>
    
    <item>
      <title>图的遍历</title>
      <link>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 07 Nov 2021 15:32:06 +0800</pubDate>
      <guid>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</guid>
      <description>&lt;h2 id=&#34;深度优先搜索&#34;&gt;深度优先搜索&lt;/h2&gt;
&lt;p&gt;辅助空间定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;bool&amp;gt; marked(G.numV); // 是否已经访问
vector&amp;lt;int&amp;gt; edgeTo(G.numV);  // 前驱顶点，便于回溯
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;深度优先搜索递归算法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void DFS(Graph &amp;amp;G, int v) {
    marked[v] = true;

    for (auto w : G.adj[v]) {
        if (!marked[w]) {
            DFS(G, w);
            edgeTo[w] = v;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在有向图中也是同理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void DFS(DiGraph &amp;amp;G, int v) {
    marked[v] = true;

    for (auto w : G.adj[v]) {
        if (!marked[w]) {
            DFS(G, w);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;广度优先搜索&#34;&gt;广度优先搜索&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void DFS(DiGraph &amp;amp;G, int v) {
    marked[v] = true;

    for (auto w : G.adj[v]) {
        if (!marked[w]) {
            DFS(G, w);
            edgeTo[w] = v;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;辅助空间定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;bool&amp;gt; marked(G.numV);   // 是否已经访问
vector&amp;lt;int&amp;gt; edgeTo(G.numV);    // 前驱结点，便于回溯
vector&amp;lt;int&amp;gt; distTo(G.numV, 0); // 路径长度
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;广度优先搜索非递归算法（借助队列）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void BFS(Graph &amp;amp;G, int s) {
    marked[s] = true;
    queue&amp;lt;int&amp;gt; q;
    q.push(s);

    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (auto w : G.adj[v]) {
            if (!marked[w]) {
                q.push(w);
                marked[w] = true;
                edgeTo[w] = v;
                distTo[w] = distTo[v] + 1;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在有向图中也是同理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void BFS(DiGraph &amp;amp;G, int s) {
    marked[s] = true;
    queue&amp;lt;int&amp;gt; q;
    q.push(s);

    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (auto w : G.adj[v]) {
            if (!marked[w]) {
                q.push(w);
                marked[w] = true;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;搜索算法的应用与挑战&#34;&gt;搜索算法的应用与挑战&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;问题&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;BFS&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;DFS&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;时间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;可达&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$E+V$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;最短路径&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$E+V$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;连通分量&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$E+V$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;重连通分量&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$E+V$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;环&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$E+V$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;欧拉回路&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$E+V$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;哈密尔顿回路&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;二部图&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$E+V$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;平面图&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;✅&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$E+V$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;图同构&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>图的连通</title>
      <link>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A/</link>
      <pubDate>Sun, 07 Nov 2021 15:33:18 +0800</pubDate>
      <guid>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A/</guid>
      <description>&lt;h2 id=&#34;连通分量&#34;&gt;连通分量&lt;/h2&gt;
&lt;p&gt;若图中的若干顶点之间两两可达，那么称这些顶点之间是连通的。&lt;/p&gt;
&lt;p&gt;无向图的极大连通子图，称为连通分量。&lt;/p&gt;
&lt;h3 id=&#34;深度优先搜索&#34;&gt;深度优先搜索&lt;/h3&gt;
&lt;p&gt;可以采用 DFS 的方法快速找到无向图中的连通分量。具体做法是，只要图中有顶点没有被访问过，那么就从中选择一个顶点开始进行 DFS，DFS 完成后将当前所有遍历过的顶点组成的子图视为一个连通分量。如此下去，直到图中所有顶点均访问完毕。&lt;/p&gt;
&lt;h4 id=&#34;算法代码&#34;&gt;算法代码&lt;/h4&gt;
&lt;p&gt;辅助空间定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;bool&amp;gt; marked(G.numV);
vector&amp;lt;int&amp;gt; id(G.numV);
int count = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;借助深度优先搜索&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void DFS(Graph G, int v) {
    marked[v] = true;
    id[v] = count;

    for (auto w : G.adj[v]) {
        if (!marked[w]) {
            DFS(G, w);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;求解无向图的强连通分量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void CC(Graph G) {
    for (int v = 0; v &amp;lt; G.numV; ++v) {
        if (!marked[v]) {
            DFS(G, v);
            ++count;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool connected(int v, int w) {
    return id[v] == id[w];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;强连通分量&#34;&gt;强连通分量&lt;/h2&gt;
&lt;p&gt;如果同时存在从 &lt;code&gt;v&lt;/code&gt; 到 &lt;code&gt;w&lt;/code&gt; 的有向路径和从 &lt;code&gt;w&lt;/code&gt; 到 &lt;code&gt;v&lt;/code&gt; 的有向路径，则顶点 &lt;code&gt;v&lt;/code&gt; 和 &lt;code&gt;w&lt;/code&gt; 是强连通的。&lt;/p&gt;
&lt;p&gt;若有向图中的若干顶点之间两两可达，那么称这些顶点之间是强连通的。若将有向图转化成无向图后，这些顶点是连通的，那么称这些顶点之间是弱连通的。&lt;/p&gt;
&lt;p&gt;有向图的极大强连通子图，称为强连通分量。有向图转化为无向图后，若出现了新的连通分量，称为弱连通分量。&lt;/p&gt;
&lt;h3 id=&#34;kosaraju-sharir-算法&#34;&gt;Kosaraju-Sharir 算法&lt;/h3&gt;
&lt;p&gt;Kosaraju-Sharir 算法是一种可以在线性时间内找到有向图强连通分量的算法，需要用到&lt;a href=&#34;../%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f&#34;&gt;拓扑排序&lt;/a&gt;的相关知识。&lt;/p&gt;
&lt;p&gt;算法首先需要构造图 $G$ 的反向图 $G^R$。显然，$G$ 和 $G^R$ 的强连通分量是完全相同的。&lt;/p&gt;
&lt;p&gt;Kosaraju-Sharir 算法接下来需要将每个顶点视为单个强连通分量以完成初始化，然后在每个强连通分量内进行拓扑排序。具体来说，算法分为如下两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算 $G^R$ 的反向后序。&lt;/li&gt;
&lt;li&gt;在 $G$ 中运行 DFS，以 $G^R$ 的反向后序访问未标记的顶点。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;算法代码-1&#34;&gt;算法代码&lt;/h4&gt;
&lt;p&gt;辅助空间定义&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;vector&amp;lt;bool&amp;gt; marked(G.numV);
vector&amp;lt;int&amp;gt; id(G.numV);
int count = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;借助深度优先搜索&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void DFS(DiGraph G, int v) {
    marked[v] = true;
    id[v] = count;

    for (auto w : G.adj[v]) {
        if (!marked[w]) {
            DFS(G, w);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;求解无向图的强连通分量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void KosarajuSharirSCC(DiGraph G) {
    for (int v : G.reverse().topo_sort()) {
        if (!marked[v]) {
            DFS(G, v);
            ++count;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;bool connected(int v, int w) {
    return id[v] == id[w];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;算法分析&#34;&gt;算法分析&lt;/h4&gt;
&lt;p&gt;时间复杂度：$O(E + V)$&lt;/p&gt;
&lt;h3 id=&#34;tarjan-算法&#34;&gt;Tarjan 算法&lt;/h3&gt;
&lt;p&gt;Tarjan 算法是一种由 Robert Tarjan 提出的求解有向图强连通分量的算法，它能做到线性时间的复杂度。&lt;/p&gt;
&lt;p&gt;在 Tarjan 算法中，有如下定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DFN[i]&lt;/code&gt;：在 DFS 中该节点被搜索的次序（时间戳），换而言之就是第几个被搜索到。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LOW[i]&lt;/code&gt;：为 &lt;code&gt;i&lt;/code&gt; 或 &lt;code&gt;i&lt;/code&gt; 的子树能够追溯到的最早的栈中节点的次序号。&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;DFN[i] == LOW[i]&lt;/code&gt; 时，&lt;code&gt;i&lt;/code&gt; 或 &lt;code&gt;i&lt;/code&gt; 的子树可以构成一个强连通分量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;算法自然语言描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先初始化一个空的栈。每次访问一个新节点（该节点入栈），如果这个点出度不为零就继续往下找，直到找到底。每次回溯时都取子节点与这个节点的 &lt;code&gt;LOW&lt;/code&gt; 值的最小值，保证最小的子树根。如果找到 &lt;code&gt;DFN == LOW&lt;/code&gt; 就说明这个节点是这个强连通分量的根节点（毕竟这个 &lt;code&gt;LOW&lt;/code&gt; 值是这个强连通分量里最小的）。最后找到强连通分量的节点后，就将这个栈里，比此节点后进来的节点全部出栈，它们就组成一个全新的强连通分量。&lt;/p&gt;
&lt;p&gt;下面来举一个具体的例子说明 Tarjan 算法的执行流程。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan1_hue959f236a875024726fc72040a9865a8_16074_0ff882dcb88cc7f24675c7424ad0bef2.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan1_hue959f236a875024726fc72040a9865a8_16074_49a3b58330dd329222d120ea228f940c.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan1_hue959f236a875024726fc72040a9865a8_16074_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan1_hue959f236a875024726fc72040a9865a8_16074_0ff882dcb88cc7f24675c7424ad0bef2.webp&#34;
               width=&#34;404&#34;
               height=&#34;250&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;如图所示的有向图中包含 3 个强连通分量，分别为 $\{1, 2, 4, 5\}$、$\{3\}$ 和 $\{6\}$。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan2_hu8708cf2985a121b1c0eade7e3420b967_19720_795ed762165b61f0fda9af48a78dc239.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan2_hu8708cf2985a121b1c0eade7e3420b967_19720_54d7c23e6a2e5e49e05e2263db34d685.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan2_hu8708cf2985a121b1c0eade7e3420b967_19720_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan2_hu8708cf2985a121b1c0eade7e3420b967_19720_795ed762165b61f0fda9af48a78dc239.webp&#34;
               width=&#34;441&#34;
               height=&#34;395&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;首先访问节点 $1$，之后陆续访问节点 $2$、$3$、$6$，&lt;code&gt;DFN&lt;/code&gt; 的值和 &lt;code&gt;LOW&lt;/code&gt; 值都相同（等于被搜索的次序）。&lt;/p&gt;
&lt;p&gt;现在发现节点 $6$ 没有后继，因此需要进行回溯。回溯第一步发现 &lt;code&gt;DFN[6] == LOW[6]&lt;/code&gt;，因此 $\{6\}$ 为强连通分量，出栈。同理，&lt;code&gt;DFN[3] == LOW[3]&lt;/code&gt;，因此 $\{3\}$ 也为强连通分量，出栈。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan3_hu4457355283f904c1c0b294083fc26948_20001_ceca42b29b87b1fbc1a5ff28a584fd29.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan3_hu4457355283f904c1c0b294083fc26948_20001_3124a83d3975d3751be8b85865673d63.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan3_hu4457355283f904c1c0b294083fc26948_20001_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan3_hu4457355283f904c1c0b294083fc26948_20001_ceca42b29b87b1fbc1a5ff28a584fd29.webp&#34;
               width=&#34;441&#34;
               height=&#34;395&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;现在回溯到节点 $2$，发现它有后继节点 $5$，继续搜索。然而节点 $5$ 的后继都已经被访问过了，因此节点 $5$ 的 &lt;code&gt;LOW&lt;/code&gt; 值需要更新，&lt;code&gt;LOW[5] = 5&lt;/code&gt;，&lt;code&gt;DFN[1] = 1&lt;/code&gt; 而 &lt;code&gt;DFN[4] = 4&lt;/code&gt;，因此 &lt;code&gt;LOW[5] = 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面仍然回溯到节点 $2$。由于节点 $5$ 已经被访问过了，节点 $2$ 的 &lt;code&gt;LOW&lt;/code&gt; 值同样也需要更新。于是 &lt;code&gt;LOW[2] = 1&lt;/code&gt;。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan4_hu1d3c1901397219d451721319c4e2e1d4_20658_07b10f14b692b2cd24bd29484fd80657.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan4_hu1d3c1901397219d451721319c4e2e1d4_20658_83aa925e05715a79204bcd90af420019.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan4_hu1d3c1901397219d451721319c4e2e1d4_20658_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan4_hu1d3c1901397219d451721319c4e2e1d4_20658_07b10f14b692b2cd24bd29484fd80657.webp&#34;
               width=&#34;441&#34;
               height=&#34;395&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来回溯到节点 $1$，发现它有后继节点 $4$，继续搜索。然而节点 $4$ 的后继都已经被访问过了，因此节点 $4$ 的 &lt;code&gt;LOW&lt;/code&gt; 值需要更新，&lt;code&gt;LOW[4] = 5&lt;/code&gt;。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan5_hu10c6a0580622aac668a8dad622e7c6e7_19688_58be42abb15f15d5c9a1dd5a8339d4a0.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan5_hu10c6a0580622aac668a8dad622e7c6e7_19688_7fd958ab9bdb6331370ba3c9cffefbb0.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan5_hu10c6a0580622aac668a8dad622e7c6e7_19688_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan5_hu10c6a0580622aac668a8dad622e7c6e7_19688_58be42abb15f15d5c9a1dd5a8339d4a0.webp&#34;
               width=&#34;441&#34;
               height=&#34;395&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;最后再次回溯到节点 $1$，此时所有的节点都已访问，并且 &lt;code&gt;DFN[1] == LOW[1]&lt;/code&gt;。因此节点 $1$ 及其后续所有节点全部出栈，$\{1, 2, 4, 5\}$ 为强连通分量。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan6_hu9b214eb7f474e1e4ebc1cb224d7d5e75_21004_1d3d5c76e311afedcbeb1e33f759ffdd.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan6_hu9b214eb7f474e1e4ebc1cb224d7d5e75_21004_7001e4abdf8738f1d96722858bd9ccdb.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan6_hu9b214eb7f474e1e4ebc1cb224d7d5e75_21004_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Tarjan6_hu9b214eb7f474e1e4ebc1cb224d7d5e75_21004_1d3d5c76e311afedcbeb1e33f759ffdd.webp&#34;
               width=&#34;382&#34;
               height=&#34;533&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;整个算法的 DFS 搜索树如图所示。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>最短路径</title>
      <link>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Fri, 26 Nov 2021 10:13:13 +0800</pubDate>
      <guid>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</guid>
      <description>&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;从图中的某个顶点出发到达另外一个顶点的所经过的边的权重和最小的一条路径，称为最短路径。&lt;/p&gt;
&lt;h3 id=&#34;单源最短路径dijkstra-算法&#34;&gt;单源最短路径：Dijkstra 算法&lt;/h3&gt;
&lt;p&gt;Dijkstra 算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法自然语言描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dijkstra 算法基于广度优先搜索算法，在遍历图的过程中更新从起点到目标节点的最短路径。算法需要用到两个数组 &lt;code&gt;dist&lt;/code&gt; 和 &lt;code&gt;visit&lt;/code&gt;，分别表示最短路径和是否被访问过。为了实现广度优先搜索，还需要使用一个队列。起点的 &lt;code&gt;dist&lt;/code&gt; 被初始化为 $0$，&lt;code&gt;visit&lt;/code&gt; 被初始化为布尔值 &lt;code&gt;true&lt;/code&gt;，然后进入队列中。其他节点的 &lt;code&gt;dist&lt;/code&gt; 被初始化为 $\infty$，&lt;code&gt;visit&lt;/code&gt; 被初始化为布尔值 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每次搜索时弹出队首节点，寻找其直接后继。在寻找直接后继的过程中，如果未访问过该节点则更新最短路径；如果访问过该节点，则需要判断如果从该节点经过到其他节点的路径是否更短，如果更短则更新到其他节点的最短路径。这个过程有一个非常形象的说法叫做边的&lt;strong&gt;松弛&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面举一个具体的例子详细说明：&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra1_hu9723dca4cb2ea058d2d8120f8dd342b0_24268_d150f02a87708a0438a138d82333ac95.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra1_hu9723dca4cb2ea058d2d8120f8dd342b0_24268_f20382ef8b1a9125e3e7e6f9ca14072b.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra1_hu9723dca4cb2ea058d2d8120f8dd342b0_24268_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra1_hu9723dca4cb2ea058d2d8120f8dd342b0_24268_d150f02a87708a0438a138d82333ac95.webp&#34;
               width=&#34;458&#34;
               height=&#34;739&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;如图所示，以 $A$ 为起点，&lt;code&gt;dist[0] = 0&lt;/code&gt;，&lt;code&gt;visit[0] = 1&lt;/code&gt;，然后节点 $A$ 进入队列中。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra2_hua8e0cb9e505e38961daa9bdbc08ed2d6_25576_ff51d61128d0df97ccf8b112315f1f07.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra2_hua8e0cb9e505e38961daa9bdbc08ed2d6_25576_98e798829a447761a0685d93491f11f9.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra2_hua8e0cb9e505e38961daa9bdbc08ed2d6_25576_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra2_hua8e0cb9e505e38961daa9bdbc08ed2d6_25576_ff51d61128d0df97ccf8b112315f1f07.webp&#34;
               width=&#34;458&#34;
               height=&#34;739&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来队首节点 $A$ 出队，它有 3 个直接后继 $C$、$E$、$F$，节点 $A$ 到这些节点的最短路径即为 3 条边上的权重。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra3_hu8595201fa36ab431e928541670dc876b_25723_4b197d2373663977ee7bee9dc616a912.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra3_hu8595201fa36ab431e928541670dc876b_25723_4b143748efcccf7a0ad5d58547c40fa4.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra3_hu8595201fa36ab431e928541670dc876b_25723_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra3_hu8595201fa36ab431e928541670dc876b_25723_4b197d2373663977ee7bee9dc616a912.webp&#34;
               width=&#34;458&#34;
               height=&#34;739&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来队首节点 $C$ 出队，它有 1 个直接后继 $D$。节点 $A$ 到节点 $D$ 的最短路径本来为 $\infty$，经过节点 $C$ 周转之后路径更短，更新为 $60$。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra4_hu8d6c626b1607fe5ac2981da4b30b9294_24739_1a4918f419d262ea052cc52bb40a3d10.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra4_hu8d6c626b1607fe5ac2981da4b30b9294_24739_9349b0a999ec6c45e9372063abdad6d1.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra4_hu8d6c626b1607fe5ac2981da4b30b9294_24739_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra4_hu8d6c626b1607fe5ac2981da4b30b9294_24739_1a4918f419d262ea052cc52bb40a3d10.webp&#34;
               width=&#34;458&#34;
               height=&#34;739&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来队首节点 $E$ 出队，它有 2 个直接后继 $D$ 和 $F$。节点 $A$ 到节点 $D$ 的最短路径本来为 $60$，经过节点 $E$ 周转之后路径更短，更新为 $50$。同理，节点 $A$ 到节点 $F$ 的最短路径本来为 $100$，经过节点 $E$ 周转之后路径更短，为 $90$。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra5_hu7c747b44735d4380c73b3beab79c4865_24702_715ea0360184e152bd70dc73dadf87b0.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra5_hu7c747b44735d4380c73b3beab79c4865_24702_477d875090f6b75a2ad7ae5329b309fc.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra5_hu7c747b44735d4380c73b3beab79c4865_24702_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra5_hu7c747b44735d4380c73b3beab79c4865_24702_715ea0360184e152bd70dc73dadf87b0.webp&#34;
               width=&#34;458&#34;
               height=&#34;739&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来队首节点 $F$ 出队，它有没有直接后继。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra6_hu30147a18b73834577a13369f0c0f0f08_24323_13eb7cb62ea8ede7764e08f10b48a534.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra6_hu30147a18b73834577a13369f0c0f0f08_24323_f7e109966acb994cdf6e69c9f3458751.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra6_hu30147a18b73834577a13369f0c0f0f08_24323_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Dijkstra6_hu30147a18b73834577a13369f0c0f0f08_24323_13eb7cb62ea8ede7764e08f10b48a534.webp&#34;
               width=&#34;458&#34;
               height=&#34;734&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;接下来队首节点 $D$ 出队，它有 1 个直接后继 $F$。节点 $A$ 到节点 $F$ 的最短路径本来为 $90$，经过节点 $D$ 周转之后路径更短，更新为 $60$。&lt;/p&gt;
&lt;h3 id=&#34;多源最短路径&#34;&gt;多源最短路径&lt;/h3&gt;
&lt;p&gt;给定一个有向图和一组源顶点，找到从集合中的任意顶点到其他顶点的最短路径。&lt;/p&gt;
&lt;p&gt;实现多源最短路径算法，只需要使用 BFS，但算法一开始需要将所有源顶点入队进行初始化。&lt;/p&gt;
&lt;p&gt;一个典型例子是网络爬虫。如果要从一个网页上爬取一些相关的连接，应该用 DFS 还是 BFS？&lt;/p&gt;
&lt;p&gt;答案显然是 BFS。因为一个网页上可能有多个网址，点开这些网址以后打开的新的网页又会有其他一些新的网址……如果采用 DFS，很可能在找第一个网址的时候就非常深入了，难以回溯。而且网络爬虫非常符合多源最短路径的场景，因为一个网页上面有多个网址（入口）。&lt;/p&gt;
&lt;h2 id=&#34;算法进阶&#34;&gt;算法进阶&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如何对边进行“松弛”？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对不同类型权重的边，需要采用合适的算法来进行“松弛”：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非负权重：Dijkstra 算法&lt;/li&gt;
&lt;li&gt;无有向循环：拓扑排序算法&lt;/li&gt;
&lt;li&gt;无负循环：Bellman-Ford 算法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;最长路径关键路径&#34;&gt;最长路径（关键路径）&lt;/h3&gt;
&lt;p&gt;应用场景：并行作业调度。给定一组具有持续时间和优先级约束的作业，安排作业（通过为每个作业找到开始时间）以达到最短完成时间，同时尊重约束。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%841_hu042cddca375d83873d3dfe0448738164_77524_152acaa091b48a75e5597cfabdb34267.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%841_hu042cddca375d83873d3dfe0448738164_77524_4db5e36704c26ee5e735dbad895e167c.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%841_hu042cddca375d83873d3dfe0448738164_77524_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%841_hu042cddca375d83873d3dfe0448738164_77524_152acaa091b48a75e5597cfabdb34267.webp&#34;
               width=&#34;760&#34;
               height=&#34;251&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;要解决并行作业调度问题，需要创建边加权 DAG。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;源和汇顶点&lt;/li&gt;
&lt;li&gt;每个作业的两个顶点（开始和结束）&lt;/li&gt;
&lt;li&gt;每个作业的三个边
&lt;ul&gt;
&lt;li&gt;开始到结束（按持续时间加权）&lt;/li&gt;
&lt;li&gt;源开始（0 权重）&lt;/li&gt;
&lt;li&gt;端到下沉（0 权重）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个优先约束的一条边（0 权重）&lt;/li&gt;
&lt;/ul&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%842_hu0ed3fc3f04d6ec0aead1ecb910306ef5_20797_5455924578764835398a15947f0fa768.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%842_hu0ed3fc3f04d6ec0aead1ecb910306ef5_20797_45aa6c41034766243b2f92445119c51d.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%842_hu0ed3fc3f04d6ec0aead1ecb910306ef5_20797_1200x1200_fit_q75_h2_lanczos.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%842_hu0ed3fc3f04d6ec0aead1ecb910306ef5_20797_5455924578764835398a15947f0fa768.webp&#34;
               width=&#34;760&#34;
               height=&#34;220&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;h3 id=&#34;负权重边&#34;&gt;负权重边&lt;/h3&gt;
&lt;p&gt;Dijkstra 算法无法处理负权重边。&lt;/p&gt;
&lt;p&gt;通过转化的方法将边权重置为非负，Dijkstra 算法仍不适用。&lt;/p&gt;
&lt;h3 id=&#34;负环&#34;&gt;负环&lt;/h3&gt;
&lt;p&gt;若出现负环，我们几乎很难判断是否有最短路径的存在。&lt;/p&gt;
&lt;p&gt;但是如果只是有环，而非负环，是可以找到最短路径的。&lt;/p&gt;
&lt;h4 id=&#34;bellman-ford-算法&#34;&gt;Bellman-Ford 算法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for (int i = 0; i &amp;lt; G.numV; ++i) {
    for (int v = 0; v &amp;lt; G.numV; ++v) {
        for (DirectedEdge &amp;amp;e : G.adj[v]) {
            relax(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;边的“松弛”&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void relax(DirectedEdge e) {
    int v = e.from(), w = e.to();
    if (distTo[w] &amp;gt; distTo[v] + e.weight()) {
        distTo[w] = distTo[v] + e.weight();
        edgeTo[w] = e;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;算法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;条件&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;时间复杂度&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;空间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;拓扑排序&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无有向环&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$E+V$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$V$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Dijkstra&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;权重非负&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$E \log V$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$V$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Bellman-Ford&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无负环&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$EV$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$V$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    
    <item>
      <title>网络流</title>
      <link>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E6%B5%81/</link>
      <pubDate>Thu, 02 Dec 2021 19:13:25 +0800</pubDate>
      <guid>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E7%BD%91%E7%BB%9C%E6%B5%81/</guid>
      <description>&lt;h2 id=&#34;流网络&#34;&gt;流网络&lt;/h2&gt;
&lt;p&gt;设 $G=(V, E)$ 是一个有向图，其中每条边 $(u, v)$ 有一个非负的容量值 $c(u, v)$。如果 $E$ 中包含一条边 $(u，v)$，那么图中就不存在它的反向边。而且，$G$ 中有且只有一个入度为零的节点 $s$ 和出度为零的节点 $t$，它们分别被称为源点和汇点。称这样的有向图 $G$ 为&lt;strong&gt;流网络&lt;/strong&gt;。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-1_hu08e8618a9f25a157aaaead30ed0de92c_14909_6d428fa1d31b3c09fc1c29c79d1d284c.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-1_hu08e8618a9f25a157aaaead30ed0de92c_14909_62c822fbb87d24d3451d0d08d52df040.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-1_hu08e8618a9f25a157aaaead30ed0de92c_14909_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-1_hu08e8618a9f25a157aaaead30ed0de92c_14909_6d428fa1d31b3c09fc1c29c79d1d284c.webp&#34;
               width=&#34;461&#34;
               height=&#34;324&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;在流网络中，边的含义不再是有向图中的权重，而是容量 $c(u, v)$。实际流过节点的网络流的流量 $f(u, v)$ 需要满足如下条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容量限制：$0 \geqslant f(u, v) \geqslant c(u, v)$&lt;/li&gt;
&lt;li&gt;流量守恒：$\sum_{u \in V} f(u, v)= \sum_{v \in V} f(u, v)$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;简单应用&#34;&gt;简单应用&lt;/h3&gt;
&lt;p&gt;流网络常见的一种应用场景是运输问题，需要将货物从 $s$ 运输到 $t$，途经几个中转站，每次运输到每个中转站的货物的数量是有限制的。在实际应用中我们可能会在某条边上双向运输，这样便违反了我们之前对流网络的定义，但是我们可以将包含反平行边的图来改造成流网络，具体的方法是引入一个是虚构的中转结点，方法如下图。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-2_hu2fc593696580a832ec28f3601714b7f1_21795_93771ecc11a475b72c90f5171d85402f.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-2_hu2fc593696580a832ec28f3601714b7f1_21795_3ec44bcb77a1924297f5b95ddbb0f752.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-2_hu2fc593696580a832ec28f3601714b7f1_21795_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-2_hu2fc593696580a832ec28f3601714b7f1_21795_93771ecc11a475b72c90f5171d85402f.webp&#34;
               width=&#34;760&#34;
               height=&#34;300&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;考虑另外一种特殊情形，从多个工厂发出货物最终运输到别的多个工厂，这时候我们具有了多个源点和多个汇点，这也很好解决，解决的方法就是人为添加超级源点 &lt;code&gt;supersource&lt;/code&gt; 和超级汇点 &lt;code&gt;supersink&lt;/code&gt;，具体方法见下图。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-3_hu1124839a6ac66d3c4a280caf0eb04ce6_37678_4a117221b45ff1c7991bce0155b944a5.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-3_hu1124839a6ac66d3c4a280caf0eb04ce6_37678_ac1d8bf6e182c2757162d110a5746f3c.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-3_hu1124839a6ac66d3c4a280caf0eb04ce6_37678_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-3_hu1124839a6ac66d3c4a280caf0eb04ce6_37678_4a117221b45ff1c7991bce0155b944a5.webp&#34;
               width=&#34;760&#34;
               height=&#34;310&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;最大流&#34;&gt;最大流&lt;/h2&gt;
&lt;p&gt;如图所示，绿色的值表示流网络中的实际流量大小，它不能够超过每条边上的容量值。&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-4_hu4b916abc7f588f74be02cd5ac0be5679_16537_dff8e25dfaa773b3c6b5e043267f83c9.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-4_hu4b916abc7f588f74be02cd5ac0be5679_16537_ca735431a383d53f7d2eda44931eb116.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-4_hu4b916abc7f588f74be02cd5ac0be5679_16537_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/maxflow-mincut-4_hu4b916abc7f588f74be02cd5ac0be5679_16537_dff8e25dfaa773b3c6b5e043267f83c9.webp&#34;
               width=&#34;461&#34;
               height=&#34;324&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;现在的问题是，整个网络存在比上图中更大的流量吗？如果有，如何求解？&lt;/p&gt;
&lt;h3 id=&#34;ford-fulkerson-算法&#34;&gt;Ford-Fulkerson 算法&lt;/h3&gt;
&lt;p&gt;Ford-Fulkerson 算法是求解流网络中的最大流的算法，其核心是通过引入残存网络 &lt;code&gt;residual network&lt;/code&gt; 和增广路径 &lt;code&gt;augmenting path&lt;/code&gt; 的概念对原先的运输方案进行纠错、改进。&lt;/p&gt;
&lt;h2 id=&#34;最小割&#34;&gt;最小割&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;最大二部图匹配&#34;&gt;最大二部图匹配&lt;/h2&gt;
&lt;p&gt;在二部图中选择尽可能多的边，并且任意两条边不共享同一节点，这就是最大二部图匹配问题。&lt;/p&gt;
&lt;p&gt;例如，有 $M$ 个求职者和 $N$ 个职位。每个求职者都有他感兴趣的工作子集。每个职位空缺只能接受一个求职者，一个求职者只能被任命为一个职位。为申请人找到工作分配，以便尽可能多的申请人获得工作。&lt;/p&gt;
&lt;p&gt;最大二部图匹配问题最终可以转化成最大流-最小割问题进行求解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>拓扑排序</title>
      <link>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Wed, 29 Dec 2021 16:27:24 +0800</pubDate>
      <guid>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;给定一组要完成的具有优先约束的任务，我们应该按照什么顺序来安排任务？&lt;/p&gt;
&lt;p&gt;将这些任务建模成 DAG (Directed acyclic graph)。于是原问题可以被转换成如下图所示的问题：&lt;/p&gt;














&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Topological-sort_hu9c7ee99c63062db6cc96f146ca279394_50690_046aa828b4fcf8eae716f0ef6a79aee3.webp 400w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Topological-sort_hu9c7ee99c63062db6cc96f146ca279394_50690_6aeb3ecb8a99da36c938a2d23d0ded32.webp 760w,
               /media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Topological-sort_hu9c7ee99c63062db6cc96f146ca279394_50690_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://bowenei.gitee.io/media/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/Topological-sort_hu9c7ee99c63062db6cc96f146ca279394_50690_046aa828b4fcf8eae716f0ef6a79aee3.webp&#34;
               width=&#34;730&#34;
               height=&#34;760&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;
&lt;p&gt;借助 DFS，可以让拓扑排序在线性时间复杂度内完成。&lt;/p&gt;
&lt;p&gt;我们需要开辟一个额外的栈空间。在 DFS 的过程中，每当访问一个未访问的顶点时，将之压入栈。在 DFS 结束以后，顶点依次出栈，所得结果即为拓扑排序结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么采用 DFS 的方法是有效的？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;后序的第一个顶点出度为 $0$&lt;/li&gt;
&lt;li&gt;后续倒数第二个顶点只能指向最后一个顶点&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;证明：DAG 的 DFS 后序序列等价于拓扑排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑任意边 &lt;code&gt;v&lt;/code&gt; $\rightarrow$ &lt;code&gt;w&lt;/code&gt;，当 &lt;code&gt;DFS(v)&lt;/code&gt; 被调用后：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;DFS(w)&lt;/code&gt; 已经被调用并且返回。因此，&lt;code&gt;w&lt;/code&gt; 在 &lt;code&gt;v&lt;/code&gt; 之前完成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DFS(w)&lt;/code&gt; 还没有被调用。&lt;code&gt;DFS(w)&lt;/code&gt; 将被 &lt;code&gt;DFS(v)&lt;/code&gt; 直接或间接调用，并将在 &lt;code&gt;DFS(v)&lt;/code&gt; 之前完成。因此，&lt;code&gt;w&lt;/code&gt; 在 &lt;code&gt;v&lt;/code&gt; 之前完成。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DFS(w)&lt;/code&gt; 已经被调用，但还没有被返回。但这种情况是不可能 DAG 中发生的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，&lt;code&gt;w&lt;/code&gt; 一定在 &lt;code&gt;v&lt;/code&gt; 之前完成。这对于任意的边来说都成立，因此整个后序序列一定是拓扑序。&lt;/p&gt;
&lt;h2 id=&#34;拓展延伸&#34;&gt;拓展延伸&lt;/h2&gt;
&lt;p&gt;定理：若有向图不存在有向环，则必然存在拓扑序。&lt;/p&gt;
&lt;p&gt;如果有向循环，拓扑顺序不可能。如果没有定向循环，则基于 DFS 的算法会找到一个拓扑顺序。&lt;/p&gt;
&lt;h3 id=&#34;优先调度&#34;&gt;优先调度&lt;/h3&gt;
&lt;p&gt;给定一组要完成的具有优先约束的任务，我们应该以什么顺序安排这些任务？&lt;/p&gt;
&lt;p&gt;注意：有向循环意味着调度问题是不可行的。&lt;/p&gt;
&lt;h3 id=&#34;循环继承&#34;&gt;循环继承&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class A extends B {
    // TODO
}

public class B extends C {
    // TODO
}

public class C extends A {
    // TODO
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>作业</title>
      <link>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A/</link>
      <pubDate>Fri, 31 Dec 2021 20:28:39 +0800</pubDate>
      <guid>https://bowenei.gitee.io/learn/algorithm/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/%E4%BD%9C%E4%B8%9A/</guid>
      <description>&lt;h2 id=&#34;找到最终的安全状态httpsleetcode-cncomproblemsfind-eventual-safe-states&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/find-eventual-safe-states/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;找到最终的安全状态&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;有向图&lt;/strong&gt;中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。&lt;/p&gt;
&lt;p&gt;对于一个起始节点，如果从该节点出发，&lt;strong&gt;无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点&lt;/strong&gt;，则将该起始节点称作是&lt;strong&gt;安全&lt;/strong&gt;的。&lt;/p&gt;
&lt;p&gt;返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按&lt;strong&gt;升序&lt;/strong&gt;排列。&lt;/p&gt;
&lt;p&gt;该有向图有 &lt;code&gt;n&lt;/code&gt; 个节点，按 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n - 1&lt;/code&gt; 编号，其中 &lt;code&gt;n&lt;/code&gt; 是 &lt;code&gt;graph&lt;/code&gt; 的节点数。图以下述形式给出：&lt;code&gt;graph[i]&lt;/code&gt; 是编号 &lt;code&gt;j&lt;/code&gt; 节点的一个列表，满足 &lt;code&gt;(i, j)&lt;/code&gt; 是图的一条有向边。&lt;/p&gt;
&lt;p&gt;依题意，此题考察的是顶点可达性的问题，涉及到 DFS 以及环的判断等知识点。&lt;/p&gt;
&lt;h3 id=&#34;方法一深度优先搜索&#34;&gt;方法一：深度优先搜索&lt;/h3&gt;
&lt;p&gt;根据题意，若起始节点位于一个环内，或者能到达一个环，则该节点不是安全的。否则，该节点是安全的。&lt;/p&gt;
&lt;p&gt;我们可以使用深度优先搜索来找环，并在深度优先搜索时，用三种颜色对节点进行标记，标记的规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;白色（用 $0$ 表示）：该节点尚未被访问；&lt;/li&gt;
&lt;li&gt;灰色（用 $1$ 表示）：该节点位于递归栈中，或者在某个环上；&lt;/li&gt;
&lt;li&gt;黑色（用 $2$ 表示）：该节点搜索完毕，是一个安全节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当我们首次访问一个节点时，将其标记为灰色，并继续搜索与其相连的节点。&lt;/p&gt;
&lt;p&gt;如果在搜索过程中遇到了一个灰色节点，则说明找到了一个环，此时退出搜索，栈中的节点仍保持为灰色，这一做法可以将「找到了环」这一信息传递到栈中的所有节点上。&lt;/p&gt;
&lt;p&gt;如果搜索过程中没有遇到灰色节点，则说明没有遇到环，那么递归返回前，我们将其标记由灰色改为黑色，即表示它是一个安全的节点。&lt;/p&gt;
&lt;h4 id=&#34;算法代码&#34;&gt;算法代码&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; eventualSafeNodes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;graph) {
        int n = graph.size();
        vector&amp;lt;int&amp;gt; color(n);

        function&amp;lt;bool(int)&amp;gt; safe = [&amp;amp;](int x) {
            if (color[x] &amp;gt; 0) {
                return color[x] == 2;
            }
            color[x] = 1;
            for (int y : graph[x]) {
                if (!safe(y)) {
                    return false;
                }
            }
            color[x] = 2;
            return true;
        };

        vector&amp;lt;int&amp;gt; ans;
        for (int i = 0; i &amp;lt; n; ++i) {
            if (safe(i)) {
                ans.push_back(i);
            }
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;算法分析&#34;&gt;算法分析&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：$O(n+m)$，其中 $n$ 是图中的点数，$m$ 是图中的边数。&lt;/li&gt;
&lt;li&gt;空间复杂度：$O(n)$。存储节点颜色以及递归栈的开销均为 $O(n)$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方法二拓扑排序&#34;&gt;方法二：拓扑排序&lt;/h3&gt;
&lt;p&gt;根据题意，若一个节点没有出边，则该节点是安全的；若一个节点出边相连的点都是安全的，则该节点也是安全的。&lt;/p&gt;
&lt;p&gt;根据这一性质，我们可以将图中所有边反向，得到一个反图，然后在反图上运行拓扑排序。&lt;/p&gt;
&lt;p&gt;具体来说，首先得到反图 $\textit{rg}$ 及其入度数组 $\textit{inDeg}$。将所有入度为 $0$ 的点加入队列，然后不断取出队首元素，将其出边相连的点的入度减一，若该点入度减一后为 $0$，则将该点加入队列，如此循环直至队列为空。循环结束后，所有入度为 $0$ 的节点均为安全的。我们遍历入度数组，并将入度为 $0$ 的点加入答案列表。&lt;/p&gt;
&lt;h4 id=&#34;算法代码-1&#34;&gt;算法代码&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; eventualSafeNodes(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;graph) {
        int n = graph.size();
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; rg(n);
        vector&amp;lt;int&amp;gt; inDeg(n);
        for (int x = 0; x &amp;lt; n; ++x) {
            for (int y : graph[x]) {
                rg[y].push_back(x);
            }
            inDeg[x] = graph[x].size();
        }

        queue&amp;lt;int&amp;gt; q;
        for (int i = 0; i &amp;lt; n; ++i) {
            if (inDeg[i] == 0) {
                q.push(i);
            }
        }
        while (!q.empty()) {
            int y = q.front();
            q.pop();
            for (int x : rg[y]) {
                if (--inDeg[x] == 0) {
                    q.push(x);
                }
            }
        }

        vector&amp;lt;int&amp;gt; ans;
        for (int i = 0; i &amp;lt; n; ++i) {
            if (inDeg[i] == 0) {
                ans.push_back(i);
            }
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;算法分析-1&#34;&gt;算法分析&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：$O(n+m)$。其中 $n$ 是图中的点数，$m$ 是图中的边数。&lt;/li&gt;
&lt;li&gt;空间复杂度：$O(n+m)$。需要 $O(n+m)$ 的空间记录反图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;判断二分图httpsleetcode-cncomproblemsis-graph-bipartite&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/is-graph-bipartite/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;判断二分图&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;问题描述-1&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;存在一个&lt;strong&gt;无向图&lt;/strong&gt;，图中有 &lt;code&gt;n&lt;/code&gt; 个节点。其中每个节点都有一个介于 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n - 1&lt;/code&gt; 之间的唯一编号。&lt;/p&gt;
&lt;p&gt;给定一个二维数组&lt;code&gt; graph&lt;/code&gt; ，表示图，其中 &lt;code&gt;graph[u]&lt;/code&gt; 是一个节点数组，由节点 &lt;code&gt;u&lt;/code&gt; 的邻接节点组成。形式上，对于 &lt;code&gt;graph[u]&lt;/code&gt; 中的每个 &lt;code&gt;v&lt;/code&gt; ，都存在一条位于节点 &lt;code&gt;u&lt;/code&gt; 和节点 &lt;code&gt;v&lt;/code&gt; 之间的无向边。该无向图同时具有以下属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不存在自环（&lt;code&gt;graph[u]&lt;/code&gt; 不包含 &lt;code&gt;u&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;不存在平行边（&lt;code&gt;graph[u]&lt;/code&gt; 不包含重复值）。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;v&lt;/code&gt; 在 &lt;code&gt;graph[u]&lt;/code&gt; 内，那么 &lt;code&gt;u&lt;/code&gt; 也应该在 &lt;code&gt;graph[v]&lt;/code&gt; 内（该图是无向图）&lt;/li&gt;
&lt;li&gt;这个图可能不是连通图，也就是说两个节点 &lt;code&gt;u&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 之间可能不存在一条连通彼此的路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;二分图&lt;/strong&gt;定义：如果能将一个图的节点集合分割成两个独立的子集 $A$ 和 $B$，并使图中的每一条边的两个节点一个来自 $A$ 集合，一个来自 $B$ 集合，就将这个图称为&lt;strong&gt;二分图&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果图是&lt;strong&gt;二分图&lt;/strong&gt;，返回 &lt;code&gt;true&lt;/code&gt;；否则，返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;问题分析&#34;&gt;问题分析&lt;/h3&gt;
&lt;p&gt;对于图中的任意两个节点 $u$ 和 $v$，如果它们之间有一条边直接相连，那么 $u$ 和 $v$ 必须属于不同的集合。&lt;/p&gt;
&lt;p&gt;如果给定的无向图连通，那么我们就可以任选一个节点开始，给它染成红色。随后我们对整个图进行遍历，将该节点直接相连的所有节点染成绿色，表示这些节点不能与起始节点属于同一个集合。我们再将这些绿色节点直接相连的所有节点染成红色，以此类推，直到无向图中的每个节点均被染色。&lt;/p&gt;
&lt;p&gt;如果我们能够成功染色，那么红色和绿色的节点各属于一个集合，这个无向图就是一个二分图；如果我们未能成功染色，即在染色的过程中，某一时刻访问到了一个已经染色的节点，并且它的颜色与我们将要给它染上的颜色不相同，也就说明这个无向图不是一个二分图。&lt;/p&gt;
&lt;p&gt;算法的流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们任选一个节点开始，将其染成红色，并从该节点开始对整个无向图进行遍历；&lt;/li&gt;
&lt;li&gt;在遍历的过程中，如果我们通过节点 $u$ 遍历到了节点 $v$（即 $u$ 和 $v$ 在图中有一条边直接相连），那么会有两种情况：
&lt;ul&gt;
&lt;li&gt;如果 $v$ 未被染色，那么我们将其染成与 $u$ 不同的颜色，并对 $v$ 直接相连的节点进行遍历；&lt;/li&gt;
&lt;li&gt;如果 $v$ 被染色，并且颜色与 $u$ 相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回 &lt;code&gt;False&lt;/code&gt; 作为答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当遍历结束时，说明给定的无向图是二分图，返回 &lt;code&gt;True&lt;/code&gt; 作为答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以使用 DFS 或 BFS 对无向图进行遍历，下文分别给出了这两种搜索对应的代码。&lt;/p&gt;
&lt;p&gt;注意：题目中给定的无向图不一定保证连通，因此我们需要进行多次遍历，直到每一个节点都被染色，或确定答案为 &lt;code&gt;False&lt;/code&gt; 为止。每次遍历开始时，我们任选一个未被染色的节点，将所有与该节点直接或间接相连的节点进行染色。&lt;/p&gt;
&lt;h3 id=&#34;算法代码-2&#34;&gt;算法代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;DFS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
private:
    static constexpr int UNCOLORED = 0;
    static constexpr int RED = 1;
    static constexpr int GREEN = 2;
    vector&amp;lt;int&amp;gt; color;
    bool valid;

public:
    bool isBipartite(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;graph) {
        int n = graph.size();
        valid = true;
        color.assign(n, UNCOLORED);

        for (int i = 0; i &amp;lt; n; ++i) {
            if (color[i] == UNCOLORED) {
                dfs(i, RED, graph);
            }
        }

        return valid;
    }

    void dfs(int node, int c, const vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;graph) {
        color[node] = c;
        int cNei = (c == RED ? GREEN : RED); // 相邻顶点颜色不能相同

        for (int neighbor : graph[node]) {
            if (color[neighbor] == UNCOLORED) {
                dfs(neighbor, cNei, graph);
                if (!valid) {
                    return;
                }
            } else if (color[neighbor] != cNei) {
                valid = false;
                return;
            }
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;BFS&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
private:
    static constexpr int UNCOLORED = 0;
    static constexpr int RED = 1;
    static constexpr int GREEN = 2;
    vector&amp;lt;int&amp;gt; color;

public:
    bool isBipartite(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph) {
        int n = graph.size();
        vector&amp;lt;int&amp;gt; color(n, UNCOLORED);
        for (int i = 0; i &amp;lt; n; ++i) {
            if (color[i] == UNCOLORED) {
                queue&amp;lt;int&amp;gt; q;
                q.push(i);
                color[i] = RED;
                while (!q.empty()) {
                    int node = q.front();
                    int cNei = (color[node] == RED ? GREEN : RED);
                    q.pop();
                    for (int neighbor: graph[node]) {
                        if (color[neighbor] == UNCOLORED) {
                            q.push(neighbor);
                            color[neighbor] = cNei;
                        }
                        else if (color[neighbor] != cNei) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;算法分析-2&#34;&gt;算法分析&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;时间复杂度&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;空间复杂度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;DFS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(V+E)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(V)$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;BFS&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(V+E)$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;$O(V)$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;最小高度树httpsleetcode-cncomproblemsminimum-height-trees&#34;&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/minimum-height-trees/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;最小高度树&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&#34;问题描述-2&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。&lt;/p&gt;
&lt;p&gt;给你一棵包含 &lt;code&gt;n&lt;/code&gt; 个节点的树，标记为 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n - 1&lt;/code&gt;。给定数字 &lt;code&gt;n&lt;/code&gt; 和一个有 &lt;code&gt;n - 1&lt;/code&gt; 条无向边的 &lt;code&gt;edges&lt;/code&gt; 列表（每一个边都是一对标签），其中 &lt;code&gt;edges[i] = [ai, bi]&lt;/code&gt; 表示树中节点 &lt;code&gt;ai&lt;/code&gt; 和 &lt;code&gt;bi&lt;/code&gt; 之间存在一条无向边。&lt;/p&gt;
&lt;p&gt;可选择树中任何一个节点作为根。当选择节点 &lt;code&gt;x&lt;/code&gt; 作为根节点时，设结果树的高度为 &lt;code&gt;h&lt;/code&gt;。在所有可能的树中，具有最小高度的树（即，&lt;code&gt;min(h)&lt;/code&gt;）被称为&lt;strong&gt;最小高度树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;请你找到所有的&lt;strong&gt;最小高度树&lt;/strong&gt;并按&lt;strong&gt;任意顺序&lt;/strong&gt;返回它们的根节点标签列表。&lt;/p&gt;
&lt;p&gt;树的&lt;strong&gt;高度&lt;/strong&gt;是指根节点和叶子节点之间最长向下路径上边的数量。&lt;/p&gt;
&lt;h3 id=&#34;问题分析-1&#34;&gt;问题分析&lt;/h3&gt;
&lt;p&gt;我们知道，树是一种特殊的图。树的叶子结点的度必然为 &lt;code&gt;1&lt;/code&gt;。因此，虽然我们并不知道最小高度树的根结点在哪里，但是我们可以确定其叶子结点一定是图中度为 &lt;code&gt;1&lt;/code&gt; 的结点。&lt;/p&gt;
&lt;p&gt;从这些叶子结点开始，不断地进行广度优先搜索。在搜索过程中删除那些已经遍历过的叶子结点，一层一层地“剥皮”。最后会出现两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只剩下一个结点。显然其度为 &lt;code&gt;0&lt;/code&gt;，而它恰恰是最小高度树的根结点。&lt;/li&gt;
&lt;li&gt;剩下两个结点，彼此之间有边相连。显然这两个结点的度均为 &lt;code&gt;1&lt;/code&gt;，而不论选择它们之中的任何一个作为根结点都可以得到最小高度树。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;算法代码-3&#34;&gt;算法代码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; findMinHeightTrees(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;edges) {
        if (n == 1) {
            return {0};
        }
        // 建立邻接列表表示的无向图
        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph(n, vector&amp;lt;int&amp;gt;());
        for (auto &amp;amp;edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        // 度为 1 的顶点（叶子结点）入队
        vector&amp;lt;int&amp;gt; degree(n, 0);
        queue&amp;lt;int&amp;gt; q;
        for (int i = 0; i &amp;lt; n; ++i) {
            degree[i] = graph[i].size();
            if (degree[i] == 1) {
                q.push(i);
            }
        }
        vector&amp;lt;int&amp;gt; roots;
        while (!q.empty()) {
            roots.clear();
            int sz = q.size();
            // 处理当前全部叶子结点并删除
            for (int i = 0; i &amp;lt; sz; ++i) {
                int t = q.front();
                q.pop();
                roots.push_back(t);
                // 加入 t 的邻接叶子结点
                degree[t]--;
                for (auto v : graph[t]) {
                    degree[v]--;
                    if (degree[v] == 1) {
                        q.push(v);
                    }
                }
            }
        }
        return roots;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;算法分析-3&#34;&gt;算法分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;时间复杂度：$O(V+E)$&lt;/li&gt;
&lt;li&gt;空间复杂度：$O(V)$&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
